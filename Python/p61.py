# This file was *autogenerated* from the file p61.sage.
from sage.all_cmdline import *   # import sage library
_sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_4 = Integer(4); _sage_const_10000 = Integer(10000); _sage_const_1000 = Integer(1000)
def polygonal_number(s, limit):
    return get_ns_less_than(lambda x: (x**_sage_const_2  * (s - _sage_const_2 ) - x*(s - _sage_const_4 )) / _sage_const_2 , limit)

def is_polygonal_number(s, n):
    return n in polygonal_number(s, n + _sage_const_1 )

def get_all_p61_cyclic(n, ns):
    res = []

    for test in ns:
        if pair_is_p61_cyclic(n, test):
            res.append(test)

    return res

def build_p61_cyclic_lists(ns, length=_sage_const_0 , verbose=_sage_const_0 ):
    nsstr = map(str, ns)
    res = map(lambda x: [x], nsstr)
    for l in xrange(length - _sage_const_1 ):
        prev_len = len(res)
        prev_res = list(enumerate(res))
        for i, numbers in prev_res:
            if verbose > _sage_const_0 :
                show_bar(i, prev_res, message='Making lists of length {}. '.format(l + _sage_const_2 ))
            for an in get_all_p61_cyclic(numbers[-_sage_const_1 ], nsstr):
                res.append(numbers + [an])

        res = res[prev_len:]

        if verbose > _sage_const_0 :
            print('')
            print('{} lists so far.'.format(len(res)))

    if verbose > _sage_const_0 :
        print('Done.')

    if verbose > _sage_const_0 :
        return map_with_progress(lambda i: map(int, i), filter_with_progress(is_p61_cyclic, res))
    else:
        return map(lambda i: map(int, i), filter(is_p61_cyclic, res))

def polygonal_type(n, mint, maxt):
    for i in xrange(maxt, mint, -_sage_const_1 ):
        if n in polygonal_number(i, n + _sage_const_1 ):
            return i

def distinct_polygonals(ns, mint, maxt):
    return is_distinct(map(lambda x: polygonal_type(x, mint, maxt), ns))

def p61(length):
    all_polygonals = set(combine_lists(map(lambda i: filter(lambda x: x >= _sage_const_1000 , polygonal_number(i, _sage_const_10000 )), (ellipsis_range(_sage_const_3 ,Ellipsis,length + _sage_const_2 )))))
    res = build_p61_cyclic_lists(all_polygonals, length, verbose=_sage_const_1 )

    distinct = filter_with_progress(lambda x: distinct_polygonals(x, _sage_const_3 , length + _sage_const_2 ), res)

    return set(map(tuple, map(sorted, distinct)))

def pair_is_p61_cyclic(f, s):
    return f[-_sage_const_2 :] == s[:_sage_const_2 ]

def is_p61_cyclic(ns):
    return is_cyclic(map(str, ns), pair_is_p61_cyclic, True)

def is_cyclic(s, f, wrap=False):
    for i, v in enumerate(s):
        if i > _sage_const_0 :
            if not f(v, s[i - _sage_const_1 ]):
                return False
        elif wrap:
            if not f(v, s[-_sage_const_1 ]):
                return False

    return True
